# 考核总结  遇到的问题和解决方法

## 1.数据结构--ArrayList

list是集合类中最基础的一种集合，平时也是我在使用java时用的最多的一种集合类。ArrayList是一种有序列表，也相当于一个容器，我们可以向容器中放入自己想要的类型，可以放入int，放入double等类型。

容器中有自带各种各样的方法，插入，删除，添加，甚至获取元素的个数等等

在做这道题目时，我遇到了如何将自己的类放入自己的Arraylist的问题，其实也是自己的思维没有转过弯来，既然要将自己的类放入ArraylList这个容器中，那么只需要将这个类实例化，再调用ArrayList的add()方法就可以了。同时要让自己的ArrayList具有泛型的特征。只能添加自己类的类型。

## 2.静态代理与动态代理

### 静态代理

代理模式的意思是为其他对象提供一种代理以访问这个对象，因为计科的学习还未接触到java的设计模式，所以一开始我有点转不过弯。其实代理的意义在现实中非常常见。让朋友打一个饭，让朋友帮你买个东西。那么这个朋友就是你的代理。

转换思维的话，如果当我们不想访问某个对象或者访问这个对象有困难，但是又想调用这个对象的方法等等的时候，就可以为这个对象去创建一个代理，通过间接的访问这个对象，还可以附加自己的操作

所以在本题中的静态代理，则需要有这4个类。

Subject --- **抽象主题类**，定义了代理对象和真实对象的共同接口方法，既可以是接口也可以是抽象类。

RealSubject --- **真实主题类**，该类可以被称为被委托类或被代理类，该类定义了代理对象所表示的真实对象，实现了Subject接口，而Client端通过代理类间接的调用的真实主题类中的方法，由其执行真正的业务逻辑。

ProxySubject --- **代理类**，该类也被称为委托类或代理类，该类中持有一个真实主题类的引用，同样实现了Subject接口，在其实现的接口方法中调用真实主题类中相应的接口方法，以此起到代理的作用。

Client --- 客户端，使用代理。（这里我用了简单Text类代替）

所以，小明想吃汉堡，让KFC帮小明制作。小明和KFC则需要一个共同的抽象主题类作为接口，定义了共同的接口方法。小明则是真实主题类，而代理类则是KFC，为了帮小明制作汉堡则需要有一个真实主题类的引用(构造参数)。之后就是编写方法了。

### 动态代理

动态代理与静态代理相比，则多了一个InvocationHandler角色和一个Proxy角色。InvocationHandler是java提供的一个接口，我们需要定义一个类实现InvocationHandler接口，这里就叫DynamicProxy角色；Proxy是java提供用于动态生成ProxySubject的一个类，它需要ProxySubject继承。(能力不够，还是无法看懂动态代理的意义)。只知道动态代理的中代理类是在代码运行中才会生成，而不像静态代理早早就定义好了，这样更有利于代码的耦合和增删查改。


 

## 3.装饰模式

  在不改变原有对象的基础之下给原有对象扩展功能，是对继承关系的一种替换方案，目的则是去扩展原有对象的功能

装饰模式的功能有以下几种

> Component 抽象角色「抽象类或接口」 抽象的构件对象，真实对象和装饰对象都实现此相同的接口,不是必须的 
>
> ConcreteComponent 具体的构件角色 即被装饰的对象可以有多个「因为被装饰的对象可以有多个」  
>
> Decorator 装饰角色 持有一个抽象构件的引用，并且把客户端的请求转发给真实的对象，起到扩展真实对象的功能，不是必须的  
>
> ConcreteDecorator 具体的装饰角色 负责给构件对象扩展功能

在本题目中， 自选配料汉堡和配料奶茶这道题我理解成人穿衣服，衣服分为上衣和裤子，而食物也分为了汉堡和奶茶，他们都属于食物，所以需要一个共有的抽象的被装饰者food接口，然后定义一个具体的构件concretecomponent，在这指汉堡或者奶茶。然后去为汉堡和奶茶分别编写添加配料的方法。去装饰汉堡和奶茶。这里我为了方便将所有配料写在了一个类中，用switch--case实现，但是完成之后发现其实要所有的配料分别写成类，更能符合装饰模式的要求，这是我没有做好的地方。

##  4.工厂模式

java中封装，多态，继承的特点在工厂模式中有的很好的体现。工厂模式指的是让将子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。**工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。** 我认为这样做的一切都是为了代码的可扩展性。就像在本题中开汉堡店的例子一样。每个地区都有不同的汉堡店，如kfc和麦当劳，汉堡店出售的汉堡也不尽相同。所以需要将工厂类定义成抽象类，给给不同的地区调用，同时产品类也要定义成抽象类，正如前面所说，不同的地区有不同的汉堡，类型也不尽相同。最后则是编写具体的制作方法。通过实例化正确的汉堡类，子类会自行照料这一切。 不用关心具体的过程

> Product：抽象产品
> ConcreteProduct：具体产品
> Factory：抽象工厂
> ConcreteFactory：具体工厂

## 5.小结

通过前面几个设计模式的学习，因为计科的java教的并不深入，所以我一开始非常的云里雾里，但是通过几天的学习和代码，我扩展了我的思维，一开始编程，更多的是实现功能，但是一个合格的程序不应该只是实现功能，还有它的可优化性和扩展性和封装性，让客户只关心结果，将过程封装，我认为设计模式的优点就是体现在这些地方，通过从抽象到具体的特点，可以大大的方便对代码的添加和以及日后的修改。计划永远赶不上变化，设计模式体现的就是一种可以不断解决变化的解决方案。



## 6.数据库

因为计科还未对数据库开展学习，所以在实现各个数据库的逻辑关系上我无法做到，只能通过这几天简单的学习去自己创建一个简单的数据库。让数据库具体题目要求的各种属性。

 ![](https://macgn.superbed.cn/item/5f9519051cd1bbb86b890fb5.png)



![](https://macgn.superbed.cn/item/5f9519051cd1bbb86b890fd6.png)

![](https://macgn.superbed.cn/item/5f9519951cd1bbb86b89304c.png)

![](https://macgn.superbed.cn/item/5f9519951cd1bbb86b89304f.png)

![](https://macgn.superbed.cn/item/5f9519051cd1bbb86b890fba.png)

![](https://macgn.superbed.cn/item/5f9519051cd1bbb86b890fc0.png)

![](https://macgn.superbed.cn/item/5f9519c81cd1bbb86b893a1c.png)

